import axios from "axios";
const aiResearch = async (query) => {
  try {
    const encodedQuery = encodeURIComponent(query);
    const url = `https://api.nekolabs.my.id/ai/ai-research?text=${encodedQuery}`;
    const { data } = await axios.get(url);
    return data.result;
  } catch (error) {
    throw new Error(
      error.response?.data?.message ||
        error.message ||
        "Gagal memanggil API ai-research"
    );
  }
};
const translateWithGoogle = async (text, target = "id") => {
  try {
    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=${target}&dt=t&q=${encodeURIComponent(
      text
    )}`;
    const res = await axios.get(url, { timeout: 15000 });
    if (!res.data || !Array.isArray(res.data[0])) return null;
    const translated = res.data[0].map((seg) => seg[0]).join("");
    return postProcessTranslation(translated);
  } catch (e) {
    return null;
  }
};
const postProcessTranslation = (text) => {
  if (!text) return text || "";
  let t = String(text).trim().replace(/\s+/g, " ");
  t = t.replace(/\s+([,.:;!?%])/g, "$1");
  t = t.replace(/([,.;:!?])(?=[^\s])/g, "$1 ");
  t = t.replace(/\s+"|"\s+/g, '"');

  const replacements = [
    [/\bAI\b/g, "AI"],
    [/\bInternet\b/g, "internet"],
    [/\bData\b/g, "data"],
    [/\bthe\b/gi, "the"], 
    [/\bThis is\b/gi, "Ini adalah"],
    [/\bThis has\b/gi, "Ini memiliki"],
  ];
  for (const [pat, rep] of replacements) {
    t = t.replace(pat, rep);
  }
  const sents = t
    .split(/([.?!])\s+/)
    .reduce((acc, cur, idx, arr) => {
      if (cur === "." || cur === "?" || cur === "!") {
        acc[acc.length - 1] = (acc[acc.length - 1] || "") + cur;
      } else {
        acc.push(cur);
      }
      return acc;
    }, [])
    .map((s) => s && s.trim())
    .filter(Boolean);
  const capped = sents
    .map((s) => {
      return s.charAt(0).toUpperCase() + s.slice(1);
    })
    .join(" ");

  return capped.replace(/\s{2,}/g, " ").trim();
};
const cleanRawReport = (raw) => {
  if (!raw) return "";
  const blacklistPatterns = [
    /Powered by\s+\w+/i,
    /Perplexity/gi,
    /AI Research Engine/gi,
    /Powered by AI/gi,
    /This content was generated by/gi,
    /Generated by/gi,
    /Subscribe/gi,
    /Visit.*for more/gi,
  ];
  const lines = raw.split(/\r?\n/);
  const cleaned = lines
    .map((ln) => ln.trim())
    .filter((ln) => {
      if (!ln) return false;
      for (const p of blacklistPatterns) {
        if (p.test(ln)) return false;
      }
      if (/^https?:\/\//i.test(ln) && ln.length < 30) return false;
      if (/^pdf:?$/i.test(ln) || /^docx:?$/i.test(ln)) return false;
      return true;
    })
    .join("\n");
  if (cleaned.split(/\s+/).length < 5) return raw;
  return cleaned;
};
const splitIntoSentences = (text) => {
  if (!text) return [];
  const sentences = text
    .replace(/\r\n/g, " ")
    .replace(/\n/g, " ")
    .split(/(?<=[.?!])\s+(?=[A-Z0-9À-ÖØ-öø-ÿ])/g);
  if (sentences.length === 1) return text.split(/(?<=[.?!])\s+/);
  return sentences;
};
const summarizeText = (text, maxSentences = 7) => {
  if (!text) return "";
  const s = splitIntoSentences(text)
    .filter(Boolean)
    .map((t) => t.trim());
  const picked = s.slice(0, maxSentences);
  return picked.join(" ").trim();
};

const extractUrls = (text) => {
  if (!text) return [];
  const urlRegex = /https?:\/\/[^\s)]+/g;
  const matches = text.match(urlRegex);
  return matches ? Array.from(new Set(matches)) : [];
};
const shortDomain = (url) => {
  try {
    const u = new URL(url);
    return u.hostname.replace(/^www\./, "");
  } catch (e) {
    return url;
  }
};
let handler = async (m, { conn, usedPrefix, text }) => {
  if (!text) {
    await conn.sendMessage(
      m.chat,
      {
        text: `Penggunaan:\n${usedPrefix}research <query>\n\nContoh:\n${usedPrefix}research demonstrasi di indonesia terjadi karena apa`,
      },
      { quoted: m }
    );
    return;
  }
  await conn.sendMessage(
    m.chat,
    { text: "🔎 Sedang mencari dan menyusun hasil research..." },
    { quoted: m }
  );
  try {
    const result = await aiResearch(text);
    const rawReportOriginal = result.report || result.summary || "";
    const rawQuery = result.query || text;
    const files = result.files || {};

    const linksToShow = [];
    if (files.pdf) linksToShow.push({ label: "PDF", url: files.pdf });
    if (files.docx) linksToShow.push({ label: "DOCX", url: files.docx });
    const cleanedRaw = cleanRawReport(rawReportOriginal);
    const shortEnglish =
      summarizeText(cleanedRaw, 0 ? 7 : 7) ||
      cleanedRaw ||
      "Maaf, ringkasan tidak tersedia dari sumber.";
    let translated = await translateWithGoogle(shortEnglish, "id");
    let translationNote = "";
    if (!translated) {
      translated = shortEnglish;
      translationNote =
        "\n\n⚠️ Catatan: Terjemahan otomatis tidak tersedia saat ini. Hasil ditampilkan dalam bahasa aslinya.";
    }
    const sents = splitIntoSentences(shortEnglish).filter(Boolean);
    let conclusionEnglish = "";
    if (sents.length >= 2) {
      conclusionEnglish = sents.slice(Math.max(0, sents.length - 2)).join(" ");
    } else {
      conclusionEnglish = shortEnglish;
    }
    let conclusionTranslated = await translateWithGoogle(
      conclusionEnglish,
      "id"
    );
    if (!conclusionTranslated) conclusionTranslated = conclusionEnglish;
    const blockedExtensions = [
      ".pdf",
      ".docx",
      ".zip",
      ".rar",
      ".7z",
      ".exe",
      ".pptx",
      ".xlsx",
      ".csv",
      ".json",
      ".xml",
      ".md",
    ];
    const urlsFromReport = extractUrls(rawReportOriginal);
    const extraFilesUrls = Object.values(files).filter(Boolean);
    const allUrls = Array.from(new Set([...urlsFromReport])).filter((url) => {
      return !blockedExtensions.some((ext) => url.toLowerCase().includes(ext));
    });
    const outLines = [];
    outLines.push(`📚 *Hasil Research "${text}" *`);
    outLines.push(`🔍 *Topik:* ${rawQuery}`);
    outLines.push("");
    if (linksToShow.length > 0) {
      outLines.push("📎 *File :*");
      for (const f of linksToShow) {
        outLines.push(`• ${f.label}: ${f.url}`);
      }
      outLines.push("");
    }

    outLines.push("────────────────────");
    outLines.push("*Ringkasan:*");
    outLines.push("");
    outLines.push(translated.trim());
    if (translationNote) outLines.push(translationNote);
    outLines.push("");
    outLines.push("*Kesimpulan:*");
    outLines.push(conclusionTranslated.trim());
    outLines.push("");

    if (allUrls.length > 0) {
      outLines.push("🔗 *Sumber & Referensi:*");
      const showUrls = allUrls.slice(0, 12); 
      for (const u of showUrls) {
        outLines.push(`• ${shortDomain(u)} — ${u}`);
      }
      if (allUrls.length > showUrls.length) {
        outLines.push(
          `• ...dan ${allUrls.length - showUrls.length} sumber lainnya`
        );
      }
    } else {
      outLines.push(
        "🔗 *Sumber:* (tidak ada URL eksplisit terdeteksi dalam laporan)"
      );
    }
    outLines.push("");
    outLines.push("© Powered by GPT, Perplexity, Gemini & some article public");
    const caption = outLines.join("\n");

    await conn.sendMessage(m.chat, { text: caption }, { quoted: m });
  } catch (e) {
    await conn.sendMessage(
      m.chat,
      {
        text:
          "" + (e.message || "Terjadi kesalahan saat memproses permintaan."),
      },
      { quoted: m }
    );
  }
};

handler.help = ["research <query>"];
handler.tags = ["tools"];
handler.command = /^research$/i;

export default handler;
